<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Audio Processor</title>
</head>
<body>
  <h1>SidePlay Audio Processor</h1>
  <p id="status">Initializing...</p>
  
  <script>
    console.log('[SidePlay Offscreen] === SCRIPT START ===');
    document.getElementById('status').textContent = 'Script loaded';
    
    // 存储每个标签页的音频上下文
    const audioContexts = new Map();
    let messageListenerRegistered = false;
    
    // 确保只注册一次 listener
    if (!messageListenerRegistered) {
      console.log('[SidePlay Offscreen] Registering message listener...');
      
      chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
        console.log('[SidePlay Offscreen] Received message:', request.action, request);
        document.getElementById('status').textContent = 'Last action: ' + request.action;
        
        try {
          if (request.action === 'initAudio') {
            initAudio(request.tabId, request.streamId).then(result => {
              console.log('[SidePlay Offscreen] initAudio result:', result);
              sendResponse(result);
            }).catch(error => {
              console.error('[SidePlay Offscreen] initAudio error:', error);
              sendResponse({ success: false, error: error.message });
            });
            return true; // 异步响应
          }
          
          if (request.action === 'setChannel') {
            const result = setChannel(request.tabId, request.channel);
            console.log('[SidePlay Offscreen] setChannel result:', result);
            sendResponse(result);
            return false;
          }
          
          if (request.action === 'cleanup') {
            cleanupTab(request.tabId);
            sendResponse({ success: true });
            return false;
          }
          
          if (request.action === 'ping') {
            sendResponse({ success: true, pong: true });
            return false;
          }
          
        } catch (error) {
          console.error('[SidePlay Offscreen] Error handling message:', error);
          sendResponse({ success: false, error: error.message });
        }
      });
      
      messageListenerRegistered = true;
      console.log('[SidePlay Offscreen] Message listener registered');
      document.getElementById('status').textContent = 'Ready';
    }
    
    // 初始化音频处理
    async function initAudio(tabId, streamId) {
      console.log('[SidePlay Offscreen] initAudio called for tab', tabId, 'streamId exists:', !!streamId);
      
      try {
        // 如果已存在，先清理
        if (audioContexts.has(tabId)) {
          console.log('[SidePlay Offscreen] Cleaning up existing context for tab', tabId);
          cleanupTab(tabId);
        }
        
        // 获取媒体流
        console.log('[SidePlay Offscreen] Requesting media stream...');
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            mandatory: {
              chromeMediaSource: 'tab',
              chromeMediaSourceId: streamId
            }
          },
          video: false
        });
        
        console.log('[SidePlay Offscreen] Got media stream for tab', tabId, 'tracks:', stream.getAudioTracks().length);
        
        const audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(stream);
        
        // 创建声道分离器和合并器
        const splitter = audioContext.createChannelSplitter(2);
        const merger = audioContext.createChannelMerger(2);
        
        // 创建增益节点控制每个声道
        const leftGain = audioContext.createGain();
        const rightGain = audioContext.createGain();
        
        // 初始为双声道
        leftGain.gain.value = 1;
        rightGain.gain.value = 1;
        
        // 连接音频图
        source.connect(splitter);
        splitter.connect(leftGain, 0);  // 左声道
        splitter.connect(rightGain, 1); // 右声道
        leftGain.connect(merger, 0, 0);
        rightGain.connect(merger, 0, 1);
        
        // 创建输出节点
        const dest = audioContext.createMediaStreamDestination();
        merger.connect(dest);
        
        // 播放处理后的音频
        const audio = new Audio();
        audio.srcObject = dest.stream;
        
        // 尝试播放
        console.log('[SidePlay Offscreen] Starting audio playback...');
        await audio.play();
        console.log('[SidePlay Offscreen] Audio playback started for tab', tabId);
        
        // 存储上下文
        audioContexts.set(tabId, {
          context: audioContext,
          leftGain,
          rightGain,
          audio,
          stream
        });
        
        document.getElementById('status').textContent = 'Active - Tab ' + tabId;
        return { success: true };
        
      } catch (error) {
        console.error('[SidePlay Offscreen] initAudio error:', error);
        document.getElementById('status').textContent = 'Error: ' + error.message;
        return { success: false, error: error.message };
      }
    }
    
    // 设置声道
    function setChannel(tabId, channel) {
      console.log('[SidePlay Offscreen] setChannel called for tab', tabId, 'channel', channel);
      const ctx = audioContexts.get(tabId);
      
      if (!ctx) {
        console.log('[SidePlay Offscreen] No audio context for tab', tabId, 'Available tabs:', Array.from(audioContexts.keys()));
        return { success: false, error: '音频未初始化' };
      }
      
      try {
        switch (channel) {
          case 'left':
            ctx.leftGain.gain.value = 1;
            ctx.rightGain.gain.value = 0;
            break;
          case 'right':
            ctx.leftGain.gain.value = 0;
            ctx.rightGain.gain.value = 1;
            break;
          case 'both':
          default:
            ctx.leftGain.gain.value = 1;
            ctx.rightGain.gain.value = 1;
            break;
        }
        
        console.log('[SidePlay Offscreen] Channel set to', channel, 'for tab', tabId);
        document.getElementById('status').textContent = 'Active - Tab ' + tabId + ' (' + channel + ')';
        return { success: true };
        
      } catch (error) {
        console.error('[SidePlay Offscreen] setChannel error:', error);
        return { success: false, error: error.message };
      }
    }
    
    // 清理标签页的音频
    function cleanupTab(tabId) {
      console.log('[SidePlay Offscreen] cleanupTab called for tab', tabId);
      const ctx = audioContexts.get(tabId);
      if (ctx) {
        try {
          ctx.audio.pause();
          ctx.audio.srcObject = null;
          ctx.stream.getTracks().forEach(track => track.stop());
          ctx.context.close();
          console.log('[SidePlay Offscreen] Cleaned up tab', tabId);
        } catch (error) {
          console.error('[SidePlay Offscreen] cleanupTab error:', error);
        }
        audioContexts.delete(tabId);
      }
    }
    
    console.log('[SidePlay Offscreen] === SCRIPT END ===');
  </script>
</body>
</html>
